---
source: Rmd
title: "Maxent model - ENMeval"
teaching: 10
exercises: 5
questions:
- "How to change parameters for Maxent?"
objectives:
- "format data input for Maxent"
- "simple run"
keypoints:
- "111111"
- "22222"
---

```{r load pk,message=FALSE,warning=FALSE,echo=FALSE}
source("../bin/chunk-options.R")
```


```{r test123}
###############################################################
library("raster")
library("dismo")

# prepare spatial occ data
if(!file.exists("data/occ_raw.rdata")){
  occ_raw <- gbif(genus="Dasypus",species="novemcinctus",download=TRUE) 
  save(occ_raw,file = "data/occ_raw.rdata")
}else{
  load("data/occ_raw.rdata")
}
occ_clean <- subset(occ_raw,(!is.na(lat))&(!is.na(lon))) 
occ_unique <- occ_clean[!duplicated( occ_clean[c("lat","lon")]  ),]
occ_unique_specimen <- subset(occ_unique, basisOfRecord=="PRESERVED_SPECIMEN")
occ_final <- subset(occ_unique_specimen, year>=1950 & year <=2000)
coordinates(occ_final) <- ~ lon + lat
myCRS1 <- CRS("+init=epsg:4326") # WGS 84
crs(occ_final) <- myCRS1

# prepare raster data
if( !file.exists( paste0("data/bioclim/bio_10m_bil.zip")   )){
  utils::download.file(url="http://biogeo.ucdavis.edu/data/climate/worldclim/1_4/grid/cur/bio_10m_bil.zip",
                       destfile="data/bioclim/bio_10m_bil.zip"   ) 
  utils::unzip("data/bioclim/bio_10m_bil.zip",exdir="data/bioclim") 
}

# load rasters
clim_list <- list.files("data/bioclim/",pattern=".bil$",full.names = T)
clim <- raster::stack(clim_list) 

occ_buffer <- buffer(occ_final,width=4*10^5) #unit is meter
clim_mask <- mask(clim, occ_buffer)

set.seed(1) 
bg <- sampleRandom(x=clim_mask,
                   size=10000,
                   na.rm=T, #removes the 'Not Applicable' points  
                   sp=T) # return spatial points 

temp1 <- extract(clim_mask[[1]],occ_final)
occ_final <- occ_final[!is.na(temp1),]
#############################################################################################################################################################################################
###########################################################
#### ENMeval practice, there are several approaches available for fine-turning Maxent model, ENMeval is just one of them############
###########################################################

library(ENMeval)


###loading occurrence and climate data, make sure that occurrence and background data only have two columns (i.e., long and lat), these are present-only data; For background data, you can use R or GIS software to generate these background data(e.g. random sampling 5000,10000),these background data should be within the accessible area (i.e. M in BAM diagram) of species in question#######


env <- clim_mask[[c("bio1","bio5","bio6","bio12")]]
#env <- stack("bio1.tif","bio5.tif","bio6.tif")

occ <- occ_final@coords
#occ <- read.csv("occ.csv", head=TRUE)

bg <- bg@coords
#bg<- read.csv("bc.csv", head=TRUE)


######start ENMeval; "RMvalues" is used to set a range of RM values, here we set RM ranged from 0.5 to 4 at at the interval of 0.5; "method" is used to spatial parting occurrence data, there are mainly two approaches available in ENM eval, i.e. block and checkerboard methods, the former method is used when your model in a transferred manner/need to be transferred (i.e. in the application of biological invasions, climate change), the latter is used in a none transfer manner (i.e. setting priority area for conservation); "fc" is used to set feature combination (for example, fc = c('L', 'LQ', 'H')), here we use default, which has six feature combinations; "overlap" is asking whether you are going to perform overlap measurements of Maxent prediction during the iterative running; "bin.output" is asking whether you are going to reserved the iterative prediction##### 

#In Maxent, the default setting are RM = 1, and fc = c("L", "LQ", "H", "LQH", "LQHP", "LQHPT")####

coc.results <- ENMevaluate(occ = occ,          ### set the occurrence data for ENMeval
                           env = env,          ### set the environmental data
                           bg.coords = bg,     ### set the background data
                           RMvalues=seq(0.5,1,0.5),   ### set the RM values, here set RM valuse from 0.5 to 5, at an interval of 0.5
                           fc = c("L", "LQ", "H", "LQH", "LQHP", "LQHPT"), # the feature combinations that will be used for iterative runningã€‚
                           method='block',            ### the method used to spatial parting occurrence records.
                           overlap=FALSE,            ### whether to perform overlap measurement of Maxent predictions among iterative running. 
                           bin.output=FALSE)       ### whether we reserve the iterative prediction of Maxent running



##################################################
#### Exploration the results ####
##################################################

# View ENMevaluation:
res <- coc.results


# Look at results table AND save it in working directory for later checking.
res@results
write.csv (res@results, file = "MyResult.csv")

# Which settings gave delta.AICc < 2?
aicmods <- which(res@results$delta.AICc < 2)
res@results[aicmods,]

# # Visualize how data were partitioned
# #1 Background points (error !!!!):
# r <- raster("bio1.tif")
# plot(r, xlim=c(-180,-20))
# points(res@bg.pts, col= res@bg.grp, cex=.75)
# 
# #2 Occurrence localities:
# plot(res@predictions[[which(res@results$delta.AICc == 0)]], xlim=c(-180,-20))
# points(res@occ.pts, pch=16, col= res@occ.grp, cex=.75)
# dev.print(tiff, "OCC_partition.tiff", res=600, units="in")


#### View predictions in geographic space for these models
plot(res@predictions[[aicmods]])

### Plot delta.AICc for different settings that we selected in ENMeval####

par(mfrow=c(2,2))
eval.plot(res@results)
eval.plot(res@results,      'avg.test.AUC')
eval.plot(res@results,      'avg.diff.AUC')
eval.plot(res@results,   'avg.test.or10pct')
eval.plot(res@resultDifs, 'avg.test.orMTP')


#####There are many fancy approaches to explore the original output of ENMeval(i.e. Myresults.csv), here deltAIC was plotted against meanAUC across diverse model setting, both these metrics can be used to measure model complexity, in this figure, the more down left of "point" position, the more less complex model setting represents#####

plot(res@results$avg.test.AUC, 
     res@results$delta.AICc, 
     bg=res@results$features, pch=21, cex= res@results$rm/2, ylim=c(0,30))
legend("topright", legend=unique(res@results$features), pt.bg=res@results$features, pch=21)
mtext("Circle size proportional to regularization multiplier value")






##################################################
#### Home work: use "block" and "checkerboard" methods to spatial parting occurrence records in ENMeval to find the best Maxent setting, and run Maxent model to compare their predictions based these setting, here are the codes####
##################################################


##preparing data, loading the occurrence, background, and environmental variables###
# 
# env <- stack("bio1.tif","bio5.tif","bio6.tif")
# 
# occ <- read.csv("occ.csv", head=TRUE)
# 
# bg<- read.csv("bc.csv", head=TRUE)


###run ENMeval using two method to spatial parting occurrence records#######
results_bl <- ENMevaluate(occ, env, bg, RMvalues=seq(0.5,4,2),method='block', overlap=FALSE, bin.output=FALSE)

results_ch <- ENMevaluate(occ, env, bg, RMvalues=seq(0.5,4,2),method='checkerboard1', overlap=FALSE, bin.output=FALSE)



###Writing the results of block method#####

res_bl <- results_bl
res_bl@results
write.csv (res_bl@results, file = "MyResult_bl.csv")


###Writing the results of checkerboard method#####
res_ch <- results_ch
res_ch@results
write.csv(res_ch@results, file = "MyResult_ch.csv")



### Selecting settings gave delta.AICc < 2 in block method####
aicmods <- which(res_bl@results$delta.AICc < 2)
res_bl@results[aicmods,]

### Selecting settings gave delta.AICc < 2 in checkerboard####
aicmods <- which(res_ch@results$delta.AICc < 2)
res_ch@results[aicmods,]


### View prediction of the best model in block and checkerboard methods#####
plot(res_bl@predictions[[aicmods]])

plot(res_ch@predictions[[aicmods]])
```

> ## Challenge: train two maxent models with different parameters, and compare the predictions     
> load occurrences & raster layers   
> build a `xxx meter` buffer around occurrences    
> `mask` raster by the buffer of occurrences   
> generate random samples from the masked raster using `sampleRandom()`  
> `extract()` environmental conditions from raster by points  
> re-format the environmental conditions as input for maxent  
> train a `maxent` model  with different paremeters
> use `devtools::source_url()` to load `prepPara()` function
> use `prepPara()` function to set different features or beta-multiplier
> use `prepPara()` function to set projection layers
> `evaluate()` the model with testing environmental conditions  
> > ## Solution
> > ```{r, echo=TRUE,eval=FALSE}
> > library("raster")
> > library("dismo")
> > 
> > # prepare spatial occ data
> > if(!file.exists("data/occ_raw.rdata")){
> >   occ_raw <- gbif(genus="Dasypus",species="novemcinctus",download=TRUE) 
> >   save(occ_raw,file = "data/occ_raw.rdata")
> > }else{
> >   load("data/occ_raw.rdata")
> > }
> > occ_clean <- subset(occ_raw,(!is.na(lat))&(!is.na(lon))) 
> > occ_unique <- occ_clean[!duplicated( occ_clean[c("lat","lon")]  ),]
> > occ_unique_specimen <- subset(occ_unique, basisOfRecord=="PRESERVED_SPECIMEN")
> > occ_final <- subset(occ_unique_specimen, year>=1950 & year <=2000)
> > coordinates(occ_final) <- ~ lon + lat
> > myCRS1 <- CRS("+init=epsg:4326") # WGS 84
> > crs(occ_final) <- myCRS1
> > 
> > # prepare raster data
> > if( !file.exists( paste0("data/bioclim/bio_10m_bil.zip")   )){
> >   utils::download.file(url="http://biogeo.ucdavis.edu/data/climate/worldclim/1_4/grid/cur/bio_10m_bil.zip",
> >                        destfile="data/bioclim/bio_10m_bil.zip"   ) 
> >   utils::unzip("data/bioclim/bio_10m_bil.zip",exdir="data/bioclim") 
> > }
> > 
> > # load rasters
> > clim_list <- list.files("data/bioclim/",pattern=".bil$",full.names = T)
> > clim <- raster::stack(clim_list) 
> > 
> > occ_buffer <- buffer(occ_final,width=4*10^5) #unit is meter
> > clim_mask <- mask(clim, occ_buffer)
> > 
> > # extract environmental conditions
> > set.seed(1) 
> > bg <- sampleRandom(x=clim_mask,
> >                    size=10000,
> >                    na.rm=T, #removes the 'Not Applicable' points  
> >                    sp=T) # return spatial points 
> > 
> > set.seed(1) 
> > 
> > # randomly select 50% for training
> > selected <- sample(  1:nrow(occ_final),  nrow(occ_final)*0.5)
> > 
> > occ_train <- occ_final[selected,] # this is the selection to be used for model training
> > occ_test <- occ_final[-selected,] # this is the opposite of the selection which will be used for model testing
> > 
> > # extracting env conditions
> > env_occ_train <- extract(clim,occ_train)
> > env_occ_test <- extract(clim,occ_test)
> > 
> > # extracting env conditions for background
> > env_bg <- extract(clim,bg)  
> > 
> > #combine the conditions by row
> > myPredictors <- rbind(env_occ_train,env_bg)
> > 
> > # change matrix to dataframe
> > myPredictors <- as.data.frame(myPredictors)
> > 
> > # repeat the number 1 as many times as the number of rows in p, and repeat 0 for the rows of background points
> > myResponse <- c(rep(1,nrow(env_occ_train)),
> >                 rep(0,nrow(env_bg))) 
> > 
> > # training a maxent model with parameters
> > myparameters1 <- prepPara(userfeatures="LQ",  
> >                           betamultiplier=0.01,
> >                           projectionlayers=paste0(getwd(),"/data/bioclim") )
> > mymodel1 <- maxent(x=myPredictors[c("bio1","bio4","bio11")],
> >                    p=myResponse,
> >                    path=paste0(getwd(),"/output/maxent_homework1"), 
> >                    args=myparameters1  ) 
> > 
> > myparameters2 <- prepPara(userfeatures="LQ",  
> >                           betamultiplier=1000)
> > mymodel2 <- maxent(x=myPredictors[c("bio1","bio4","bio11")],
> >                      p=myResponse,
> >                      path=paste0(getwd(),"/output/maxent_homework2"), 
> >                      args=myparameters2  ) 
> > 
> > # evaluate model based on testing data
> > mod_eval1 <- dismo::evaluate(p=env_occ_test,
> >                                  a=env_bg,
> >                                  model=mymodel1) 
> > mod_eval2 <- dismo::evaluate(p=env_occ_test,
> >                                  a=env_bg,
> >                                  model=mymodel2) 
> > 
> > mod_eval1@auc
> > mod_eval2@auc
> > ```
> {: .solution}
{: .challenge}
{% include links.md %}

